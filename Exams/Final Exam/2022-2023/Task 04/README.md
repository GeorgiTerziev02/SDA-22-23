# Task: Най-кратка поредица от пътища (Medium) - [HackerRank](<https://www.hackerrank.com/contests/sda-exam-20222023-part-2/challenges/--152>)


### Statement:

Даден ви е граф с $N$ върха и $M$ ребра и поредица от $P$ върха в графа $A[0], A[1] ... A[P-1]$. **Трябва да обходите върховете точно в тази последователност използвайки най-краткият път като може да повтаряте върхове**. 

Също така имате дадена поредица от $K$ върха $B[0], B[1] ... B[K-1]$, през които не трябва да минавате.

Иначе казано трябва да намерите най-краткият от $A[0]$ до $A[1]$ (този път не трябва да съдържа никой от $A[2], A[3] ... A[P-1]$ (тъй като те трябва да се срещнат след $A[0]$ и $A[1]$), както и никой от $MISSING$ (тъй като са забранени)), след това да намерите най-краткият път между $MISSING$ и $MISSING$ и тн.

Забележка: Пътят между $A[1]$ и $A[2]$ може да съдържа вече срещнати обходени върхове стига те да не са измежду $A[3], A[4], ... A[P-1], B[0], B[1], ... B[K-1]$.


### Input format

На първия ред са ви дадени $N$ и $M$

На следващите $M$ реда се въвеждат по 2 числа на ред - ребрата в графа

На следващия ред се въвежда $P$.

На следващите $P$ реда се въвеждат индексите на върховете $A[0], A[1] ... A[P-1]$

На следващия ред се въвежда $K$

На следващите $K$ реда се въвеждат индексите на върховете $B[0], B[1] ... B[K-1]$


### Constraints

$1 \le N,P,K \le 10^3$

$1 \le M \le 10^6$


### Output format

На първия ред на стандартния изход се извежда дължината на търсеният път. Приемете, че такъв път винаги ще съществува.


### Samples


#### Sample Input 0
```
6 6
1 2 
2 0
3 0 
4 0 
1 5 
5 4 
3
1 0 3
1
2
```

#### Sample Output 0
```
4
```

#### Explanation 0
Въпреки, че тук най-краткият път се получава ако минем по пътя 1 -&gt; 2 -&gt; 0 -&gt; 3, това е невалиден път, тъй като върхът 2 е от тези, през които не можем да минаваме. Затова най-краткият път в случая е 1 -&gt; 5 -&gt; 4 -&gt; 0 -&gt; 3, който е с дължина 4(минава през 4 ребра). 
<img src="https://s3.amazonaws.com/hr-assets/0/1675609658-474f973d86-Screenshot2023-02-05at17.07.32.png" alt="image" title="">

#### Sample Input 1
```
5 3
0 1
2 0 
3 1
3 
0 3 2
1 
5 
```

#### Sample Output 1
```
5
```

#### Explanation 1
Тук пътят е 0 -&gt; 1 -&gt; 3 -&gt; 1 -&gt; 0 -&gt; 2
<img src="https://s3.amazonaws.com/hr-assets/0/1675609781-5778c7a890-Screenshot2023-02-05at17.09.34.png" alt="image" title="">

#### Sample Input 2
```
6 5 
0 1
1 2 
2 3 
3 4 
4 0 
3
0 2 1 
1 
5 
```

#### Sample Output 2
```
4
```

#### Explanation 2
Тук най-краткият път е 0 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 
Забележете, че въпреки че 0 -&gt; 1 -&gt; 2 -&gt; 1 е по-кратък, той е невалиден, тъй като 1 се среща преди 2, а ние искаме върховете да се срещат точно в последователността 0, 2, 1 (първото срещане на 0 да е преди първото срещане на 2 и то да е преди първото срещане на 1)
<img src="https://s3.amazonaws.com/hr-assets/0/1675610050-f0eac23bb0-Screenshot2023-02-05at17.14.06.png" alt="image" title="">
